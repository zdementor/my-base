
require "shadergen/shadergen_common"
require "shadergen/shadergen_glsl12"
require "shadergen/shadergen_hlsl20"

ShaderGen =
{
	init,
	getMaxLightsCount,
	--------------------------------------------------------------------------------
	-- INFO: Returns generated sources for vertex type, render pass and lights count
	--------------------------------------------------------------------------------
	-- PARAMETERS:
	--   vertex_type
	--   render_pass
	--   lights_count
	--
	-- RETURNS:
	--   sources - generated program sources
	--     {
	--       LightsCount = 4,
	--       Uniforms = bit.bor(vid.EUF_MODEL_VIEW_MATRIX, vid.EUF_NORMAL_MATRIX),
	--       Vertex = { Source = "void main(void) {}", Ver = vid.EVSV_GLSL_1_2 },
	--       Pixel  = { Source = "void main(void) {}", Ver = vid.EPSV_GLSL_1_2 },
	--     }
	--------------------------------------------------------------------------------	
	getSourcesFor,
	getCurrentTag,
	getTagsCount,
	getTag,
}

SHADERGEN_MAX_LIGHTS_COUNT = 4

local _ShaderGen =
{
	[vid.EDT_OPENGL21] =
	{
		VertexShaderVer = vid.EVSV_GLSL_1_2,
		PixelShaderVer = vid.EPSV_GLSL_1_2,
		GenVertexShader	= GLSL12GenVertexShader,
		GenPixelShader	= GLSL12GenPixelShader,
	},
	[vid.EDT_DIRECTX9] =
	{
		VertexShaderVer = vid.EVSV_HLSL_2_a,
		PixelShaderVer = vid.EPSV_HLSL_2_a,
		GenVertexShader	= HLSL20GenVertexShader,
		GenPixelShader	= HLSL20GenPixelShader,
	},
}

local _UniformsMask =
{
	Vertex = vid.EUF_NONE,
	Pixel = vid.EUF_NONE,
}

GenTCInfo = {}

local function _GenUniforms(vtype, pass, perpixel, lightcnt)

	local vsh	= ""
	local psh	= ""
	local light = IsLighting(pass, lightcnt)
	local vnormal = HasNormal(vtype)
	local mcolor = IsCustomVertexColor(vtype, pass)
	local hasNMap = HasNMap(pass)
	local fogging = IsFogging(pass)
	
	_UniformsMask.Vertex = vid.EUF_NONE
	_UniformsMask.Pixel = vid.EUF_NONE
	
	_UniformsMask.Vertex = bit.bor(_UniformsMask.Vertex,
		vid.EUF_MODEL_VIEW_PROJ_MATRIX)
		
	if IsNeedNormal(vtype, pass, lightcnt) then
		_UniformsMask.Vertex = bit.bor(_UniformsMask.Vertex,
			vid.EUF_MODEL_VIEW_MATRIX)
			
		_UniformsMask.Vertex = bit.bor(_UniformsMask.Vertex,
			vid.EUF_NORMAL_MATRIX)
		if light then
			if perpixel then
				_UniformsMask.Pixel = bit.bor(_UniformsMask.Pixel,
					vid.EUF_GLOBAL_AMBIENT_COLOR,
					vid.EUF_MATERIAL_COLORS, vid.EUF_MATERIAL_SHININESS,
					vid.EUF_LIGHTING)
				if HasTBN(vtype) then
					_UniformsMask.Vertex = bit.bor(_UniformsMask.Vertex,
						vid.EUF_LIGHTING)
				end
			else
				_UniformsMask.Vertex = bit.bor(_UniformsMask.Vertex,
					vid.EUF_GLOBAL_AMBIENT_COLOR,
					vid.EUF_MATERIAL_COLORS, vid.EUF_MATERIAL_SHININESS,
					vid.EUF_LIGHTING)
			end
		end
	elseif hasNMap then
		_UniformsMask.Vertex = bit.bor(_UniformsMask.Vertex,
			vid.EUF_MODEL_VIEW_MATRIX)
	elseif fogging then
		_UniformsMask.Vertex = bit.bor(_UniformsMask.Vertex,
			vid.EUF_MODEL_VIEW_MATRIX)
	end
	
	if mcolor then
		_UniformsMask.Vertex = bit.bor(_UniformsMask.Vertex,
			vid.EUF_MATERIAL_COLORS)
	end

	for i = 1, table.getn(GenTCInfo) do
		local idx = GenTCInfo[i].LayerIdx
		if GenTCInfo[i].Name ~= nil then
			local texture = pass.Layers[idx]:getTexture()
			if texture ~= nil then
				if pass.Layers[idx]:getType() ~= vid.ETLT_NORMAL_MAP or perpixel then
					_UniformsMask.Pixel = bit.bor(_UniformsMask.Pixel, TexFlags[idx+1])
					if pass.Layers[idx]:isTexCoordAnimated() then
						_UniformsMask.Vertex = bit.bor(_UniformsMask.Vertex,
							TexMatrixFlags[idx+1])
					end
					if pass.Layers[idx]:getTexCoordGen() == vid.ETCGT_PROJECTED_MAPPING then
						_UniformsMask.Vertex = bit.bor(_UniformsMask.Vertex,
							TexMatrixFlags[idx+1], vid.EUF_MODEL_MATRIX)
					end
				end
			end
		end
	end

	if fogging then
		_UniformsMask.Pixel = bit.bor(_UniformsMask.Pixel,
			vid.EUF_FOG_PARAMS)
		_UniformsMask.Pixel = bit.bor(_UniformsMask.Pixel,
			vid.EUF_FOG_COLOR)
	end
	
	return bit.bor(_UniformsMask.Vertex, _UniformsMask.Pixel)
end

local function _GenShaderHeader()
	local text = ""
	text = text.."// This file automaticaly generated by MyEngine Shader Generator\n"
	text = text..string.format("// Date/time: %s\n", os.getCurrentTimeString())--os.date())
	text = text.."// DON'T EDIT this file or you may lost your changes!\n\n"
	return text
end

function _ShaderGenGenGPUProgram(vtype, arg1, lightcnt)
	local pass = tolua.cast(arg1, "const vid::SRenderPass")
	local sources = ShaderGen.getSourcesFor(vtype, pass, lightcnt)
	if sources ~= nil then
		MyDriver:addGPUProgram(
			vtype, pass, sources.Uniforms, sources.LightsCount,
			sources.Vertex.Ver, sources.Vertex.Source,
			sources.Pixel.Ver, sources.Pixel.Source,
			sources.Tag)
	else
		MyLogger:logErr(string.format(
			"ShaderGen: Can't add GPU program sources for vtype=%s lights=%d",
			vid.getVertexTypeName(vtype), lightcnt
			))
	end
end

local function _ShaderGenInit()
	MyScript:setScriptCallback(scr.ESCT_GEN_GPU_PROGRAM,
		"_ShaderGenGenGPUProgram")
	MyScript:setScriptCallback(scr.ESCT_GET_GEN_GPU_PROGRAM_MAX_LIGHTS,
		"_ShaderGenGetMaxLightsCount")
	MyScript:setScriptCallback(scr.ESCT_GET_GEN_GPU_PROGRAM_TAG,
		"_ShaderGenGetCurrentTag")
end
ShaderGen.init = _ShaderGenInit

function _ShaderGenGetMaxLightsCount()
	return SHADERGEN_MAX_LIGHTS_COUNT
end
ShaderGen.getMaxLightsCount = _ShaderGenGetMaxLightsCount

local driver_type = MyDriver:getDriverType()
local perpixel  = MyDevice:getDeviceFlagValue(dev.EDCF_SHADERS_HIGH_QUALITY)

local function _ShaderGenGetSourcesFor(vertex_type, render_pass, lights_count)
	local sources = nil
	if render_pass ~= nil
			and _ShaderGen[driver_type].GenVertexShader ~= nil
			and _ShaderGen[driver_type].GenPixelShader ~= nil then
		sources = {}
		if lights_count > SHADERGEN_MAX_LIGHTS_COUNT then
			lights_count = SHADERGEN_MAX_LIGHTS_COUNT
		end
		GenInfo(vertex_type, render_pass, perpixel, lights_count)
		sources.Tag = ShaderGen.getCurrentTag()
		sources.LightsCount = lights_count
		sources.Uniforms = _GenUniforms(vertex_type, render_pass, perpixel, lights_count)
		sources.Vertex = {}
		sources.Vertex.Ver = _ShaderGen[driver_type].VertexShaderVer
		sources.Vertex.Source = _GenShaderHeader().._ShaderGen[driver_type].GenVertexShader(
			vertex_type, render_pass, perpixel, lights_count, _UniformsMask.Vertex)
		sources.Pixel = {}
		sources.Pixel.Ver = _ShaderGen[driver_type].PixelShaderVer
		sources.Pixel.Source = _GenShaderHeader().._ShaderGen[driver_type].GenPixelShader(
			vertex_type, render_pass, perpixel, lights_count, _UniformsMask.Pixel)
	end
	return sources
end
ShaderGen.getSourcesFor = _ShaderGenGetSourcesFor

local _ShaderGenTags =
{
	[1] = "LowQual",
	[2] = "HighQual",
}

function _ShaderGenGetCurrentTag()
	local tag = _ShaderGenTags[1]
	if SETUP_SETTINGS[StartupDriverIndex].ShadersHighQuality == 1 then
		tag = _ShaderGenTags[2]
	end
	return tag
end
ShaderGen.getCurrentTag = _ShaderGenGetCurrentTag

function _ShaderGenGetTagsCount()
	return table.getn(_ShaderGenTags)
end
ShaderGen.getTagsCount = _ShaderGenGetTagsCount

function _ShaderGenGetTag(index)
	local idx = 1
	if index ~= nil then
		idx = tonumber(index) + 1
	end
	return _ShaderGenTags[idx]
end
ShaderGen.getTag = _ShaderGenGetTag
