//|-------------------------------------------------------------------------
//| File:        CShadowFake.cpp
//|
//| Descr:       This file is a part of the 'MyEngine'
//| Author:      Zhuk 'zdementor' Dmitry (aka ZDimitor)
//| Email:       zdimitor@pochta.ru, sibergames@nm.ru
//|
//|     Copyright (c) 2004-2009 by Zhuk Dmitry, Krasnoyarsk - Moscow
//|                      All Rights Reserved.
//|-------------------------------------------------------------------------

#include "CShadowFake.h"

#include <scn/ISceneManager.h>
#include <vid/IVideoDriver.h>
#include <io/IFileSystem.h>
#include <img/IImageLibrary.h>
#include <scn/IPathFinderManager.h>
#include <scn/IBillboardSceneNode.h>
#include <dev/IProfiler.h>
#include <os/ITimer.h>

//---------------------------------------------------------------------------
namespace my {
namespace scn {
//---------------------------------------------------------------------------

const int FILE_LENGTH = 1836;
u8 file_data[FILE_LENGTH] =
{
0x00, 0x01, 0x01, 0x00, 0x00, 0x00, 0x01, 0x18, 0x00, 0x00, 0x00, 0x00, 0x20, 0x00, 0x20, 0x00, 0x08, 0x08, 0x00, 0x00, 0x00, 
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xFF, 0xFF, 
0xFF, 0x02, 0x02, 0x02, 0x05, 0x05, 0x05, 0x06, 0x06, 0x06, 0x08, 0x08, 0x08, 0x0A, 0x0A, 0x0A, 0x0C, 0x0C, 0x0C, 0x0E, 
0x0E, 0x0E, 0x12, 0x12, 0x12, 0x14, 0x14, 0x14, 0x17, 0x17, 0x17, 0x18, 0x18, 0x18, 0x1B, 0x1B, 0x1B, 0x1D, 0x1D, 0x1D, 
0x21, 0x21, 0x21, 0x23, 0x23, 0x23, 0x24, 0x24, 0x24, 0x27, 0x27, 0x27, 0x29, 0x29, 0x29, 0x2A, 0x2A, 0x2A, 0x2D, 0x2D, 
0x2D, 0x2E, 0x2E, 0x2E, 0x2F, 0x2F, 0x2F, 0x31, 0x31, 0x31, 0x32, 0x32, 0x32, 0x33, 0x33, 0x33, 0x34, 0x34, 0x34, 0x36, 
0x36, 0x36, 0x37, 0x37, 0x37, 0x39, 0x39, 0x39, 0x3B, 0x3B, 0x3B, 0x3E, 0x3E, 0x3E, 0x3F, 0x3F, 0x3F, 0x40, 0x40, 0x40, 
0x48, 0x48, 0x48, 0x4B, 0x4B, 0x4B, 0x4C, 0x4C, 0x4C, 0x4F, 0x4F, 0x4F, 0x50, 0x50, 0x50, 0x55, 0x55, 0x55, 0x56, 0x56, 
0x56, 0x59, 0x59, 0x59, 0x5A, 0x5A, 0x5A, 0x5F, 0x5F, 0x5F, 0x66, 0x66, 0x66, 0x68, 0x68, 0x68, 0x69, 0x69, 0x69, 0x6B, 
0x6B, 0x6B, 0x6C, 0x6C, 0x6C, 0x6E, 0x6E, 0x6E, 0x71, 0x71, 0x71, 0x73, 0x73, 0x73, 0x75, 0x75, 0x75, 0x77, 0x77, 0x77, 
0x7D, 0x7D, 0x7D, 0x80, 0x80, 0x80, 0x83, 0x83, 0x83, 0x86, 0x86, 0x86, 0x8B, 0x8B, 0x8B, 0x8D, 0x8D, 0x8D, 0x8E, 0x8E, 
0x8E, 0x91, 0x91, 0x91, 0x95, 0x95, 0x95, 0x97, 0x97, 0x97, 0x98, 0x98, 0x98, 0x9C, 0x9C, 0x9C, 0x9F, 0x9F, 0x9F, 0xA5, 
0xA5, 0xA5, 0xA6, 0xA6, 0xA6, 0xA8, 0xA8, 0xA8, 0xAB, 0xAB, 0xAB, 0xAD, 0xAD, 0xAD, 0xAF, 0xAF, 0xAF, 0xB1, 0xB1, 0xB1, 
0xB5, 0xB5, 0xB5, 0xB7, 0xB7, 0xB7, 0xB9, 0xB9, 0xB9, 0xBB, 0xBB, 0xBB, 0xBC, 0xBC, 0xBC, 0xC1, 0xC1, 0xC1, 0xC4, 0xC4, 
0xC4, 0xC7, 0xC7, 0xC7, 0xCB, 0xCB, 0xCB, 0xCE, 0xCE, 0xCE, 0xD0, 0xD0, 0xD0, 0xD1, 0xD1, 0xD1, 0xD3, 0xD3, 0xD3, 0xD6, 
0xD6, 0xD6, 0xD7, 0xD7, 0xD7, 0xD9, 0xD9, 0xD9, 0xDD, 0xDD, 0xDD, 0xDF, 0xDF, 0xDF, 0xE0, 0xE0, 0xE0, 0xE2, 0xE2, 0xE2, 
0xE5, 0xE5, 0xE5, 0xE7, 0xE7, 0xE7, 0xE8, 0xE8, 0xE8, 0xE9, 0xE9, 0xE9, 0xEA, 0xEA, 0xEA, 0xEB, 0xEB, 0xEB, 0xED, 0xED, 
0xED, 0xEF, 0xEF, 0xEF, 0xF0, 0xF0, 0xF0, 0xF1, 0xF1, 0xF1, 0xF2, 0xF2, 0xF2, 0xFA, 0xFA, 0xFA, 0xFB, 0xFB, 0xFB, 0xFD, 
0xFD, 0xFD, 0xFE, 0xFE, 0xFE, 0x97, 0x97, 0x98, 0xD4, 0xD4, 0xD5, 0xD7, 0xD7, 0xD8, 0xDF, 0xDF, 0xE0, 0xE9, 0xE9, 0xEA, 
0xE7, 0xE8, 0xE8, 0x01, 0x02, 0x02, 0xE9, 0xEA, 0xE9, 0x80, 0x80, 0x7F, 0x86, 0x86, 0x85, 0x8C, 0x8C, 0x8B, 0xA0, 0xA0, 
0x9F, 0xA6, 0xA6, 0xA5, 0xAC, 0xAC, 0xAB, 0xB2, 0xB2, 0xB1, 0xBF, 0xBF, 0xBE, 0xC3, 0xC3, 0xC2, 0xDB, 0xDB, 0xDA, 0xF8, 
0xF8, 0xF7, 0xF9, 0xF9, 0xF8, 0x63, 0x63, 0x62, 0x6A, 0x6A, 0x69, 0x6C, 0x6C, 0x6B, 0x76, 0x76, 0x75, 0x7F, 0x7F, 0x7E, 
0x80, 0x7F, 0x7F, 0x82, 0x81, 0x81, 0x89, 0x88, 0x88, 0x8A, 0x89, 0x89, 0x8E, 0x8D, 0x8D, 0x92, 0x91, 0x91, 0x93, 0x92, 
0x92, 0x94, 0x93, 0x93, 0x96, 0x95, 0x95, 0x9A, 0x99, 0x99, 0x9B, 0x9A, 0x9A, 0x9C, 0x9B, 0x9B, 0x9E, 0x9D, 0x9D, 0xA1, 
0xA0, 0xA0, 0xA3, 0xA2, 0xA2, 0xA4, 0xA3, 0xA3, 0xA6, 0xA5, 0xA5, 0xA8, 0xA7, 0xA7, 0xB6, 0xB5, 0xB5, 0xC6, 0xC5, 0xC5, 
0xC8, 0xC7, 0xC7, 0xCC, 0xCB, 0xCB, 0xD8, 0xD7, 0xD7, 0xDA, 0xD9, 0xD9, 0xDE, 0xDD, 0xDD, 0xE2, 0xE1, 0xE1, 0xEE, 0xED, 
0xED, 0xF5, 0xF4, 0xF4, 0xFE, 0xFD, 0xFD, 0x58, 0x57, 0x57, 0x5C, 0x5B, 0x5B, 0x5E, 0x5D, 0x5D, 0x60, 0x5F, 0x5F, 0x61, 
0x60, 0x60, 0x62, 0x61, 0x61, 0x65, 0x64, 0x64, 0x6A, 0x69, 0x69, 0x6C, 0x6B, 0x6B, 0x78, 0x77, 0x77, 0x79, 0x78, 0x78, 
0x7A, 0x79, 0x79, 0x7C, 0x7B, 0x7B, 0x40, 0x3F, 0x3F, 0x42, 0x41, 0x41, 0x43, 0x42, 0x42, 0x44, 0x43, 0x43, 0x45, 0x44, 
0x44, 0x47, 0x46, 0x46, 0x48, 0x47, 0x47, 0x4C, 0x4B, 0x4B, 0x4E, 0x4D, 0x4D, 0x50, 0x4F, 0x4F, 0x52, 0x51, 0x51, 0x54, 
0x53, 0x53, 0x3C, 0x3B, 0x3B, 0x3D, 0x3C, 0x3C, 0x3E, 0x3D, 0x3D, 0x20, 0x1F, 0x1F, 0x1C, 0x1B, 0x1B, 0x18, 0x17, 0x17, 
0x84, 0x83, 0x84, 0x9E, 0x9D, 0x9E, 0xA4, 0xA3, 0xA4, 0xA6, 0xA5, 0xA6, 0xAA, 0xA9, 0xAA, 0xB2, 0xB1, 0xB2, 0xB3, 0xB2, 
0xB3, 0xC0, 0xBF, 0xC0, 0xC2, 0xC1, 0xC2, 0xC6, 0xC5, 0xC6, 0xC9, 0xC8, 0xC9, 0xCA, 0xC9, 0xCA, 0xCD, 0xCC, 0xCD, 0xE2, 
0xE1, 0xE2, 0xEE, 0xED, 0xEE, 0xF0, 0xEF, 0xF0, 0xF7, 0xF6, 0xF7, 0xF8, 0xF7, 0xF8, 0xFA, 0xF9, 0xFA, 0x5D, 0x5C, 0x5D, 
0x70, 0x6F, 0x70, 0x76, 0x75, 0x76, 0x7A, 0x79, 0x7A, 0x7B, 0x7A, 0x7B, 0x7C, 0x7B, 0x7C, 0x42, 0x41, 0x42, 0x53, 0x52, 
0x53, 0x3A, 0x39, 0x3A, 0x2E, 0x2D, 0x2E, 0x32, 0x31, 0x32, 0x26, 0x25, 0x26, 0x1F, 0x1E, 0x1F, 0x01, 0x01, 0x01, 0xFF, 
0xFF, 0xFF, 0x00, 0x00, 0x00, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 
0xFD, 0xFD, 0xFD, 0xFD, 0xFD, 0xFF, 0xFF, 0xFF, 0xFF, 0xFD, 0xFD, 0xFD, 0xFD, 0xFD, 0xFD, 0xFD, 0xFD, 0xFF, 0xFF, 0xFF, 
0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0x1C, 0x1C, 0x1E, 0x21, 0x21, 0x20, 0x1E, 0x1D, 0x1C, 0x1C, 0xFD, 0xFD, 
0xFD, 0xFD, 0xFD, 0xFD, 0xFD, 0xFD, 0xFD, 0xFD, 0xFD, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0x1C, 0x23, 
0x28, 0xFB, 0x2E, 0x31, 0x32, 0x32, 0x2F, 0xFB, 0xFC, 0x24, 0x1E, 0x1C, 0xFD, 0xFD, 0xFD, 0xFD, 0x8E, 0xFD, 0xFD, 0xFD, 
0xFD, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0x1C, 0x24, 0x2B, 0x34, 0x3A, 0xD1, 0x40, 0xD6, 0x42, 0x42, 0x40, 0x3D, 
0x3B, 0x35, 0x2C, 0x26, 0x1D, 0x1C, 0x1C, 0xFD, 0xFD, 0xFD, 0xFD, 0xFD, 0xFD, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0x20, 
0xDA, 0x34, 0xCF, 0xD6, 0x9C, 0x4D, 0xF4, 0x52, 0x53, 0xA2, 0xF5, 0x4E, 0x47, 0x43, 0xD0, 0x36, 0x2A, 0x22, 0x1C, 0x1C, 
0xFD, 0xFD, 0xFD, 0xFD, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0x22, 0x2D, 0xD8, 0xF7, 0x49, 0xF5, 0x57, 0xAC, 0xDF, 0xE1, 
0x95, 0x61, 0xE0, 0xDE, 0x58, 0xA1, 0xC6, 0x42, 0x3C, 0x2E, 0x24, 0x1C, 0x1C, 0xFD, 0xFD, 0xFD, 0xFF, 0xFF, 0xFF, 0xFF, 
0xFF, 0x22, 0x2D, 0xF6, 0xBF, 0xF2, 0x56, 0xDF, 0x64, 0x97, 0xE6, 0x6D, 0xE9, 0xB6, 0xB5, 0xE4, 0x65, 0x5F, 0xA7, 0xF3, 
0x46, 0xCF, 0x2F, 0x24, 0x1C, 0xFD, 0xFD, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0x1E, 0x2C, 0xCC, 0xF0, 0xCA, 0x5B, 0x63, 0xE5, 
0x6E, 0x73, 0x75, 0xBA, 0xEA, 0xBA, 0xB9, 0x74, 0x6F, 0x6B, 0xE3, 0xAD, 0xA2, 0xC3, 0xCF, 0x2E, 0x22, 0x1C, 0xFD, 0xFF, 
0xFF, 0xFF, 0xFF, 0xFD, 0xFC, 0xF8, 0x45, 0xF3, 0xAB, 0xE3, 0xE7, 0x73, 0xBA, 0x7B, 0x7F, 0xEC, 0x81, 0x81, 0xEB, 0x7C, 
0x78, 0xB8, 0xE9, 0x67, 0xAE, 0xA2, 0x46, 0x3C, 0x2A, 0x1D, 0xFD, 0xFF, 0xFF, 0xFF, 0xFF, 0x22, 0x32, 0x40, 0x4E, 0x59, 
0xE2, 0xE8, 0xB8, 0x7A, 0x80, 0xBC, 0xED, 0x9B, 0x9B, 0x9B, 0xED, 0xBC, 0x80, 0x7B, 0xB9, 0x6E, 0x67, 0x5C, 0xC9, 0x42, 
0x36, 0x25, 0x1C, 0xFF, 0xFF, 0xFF, 0xFD, 0x29, 0x3C, 0xC4, 0x54, 0xE1, 0x6B, 0x74, 0x7B, 0x82, 0x9A, 0x85, 0x86, 0x86, 
0x86, 0x86, 0x86, 0x84, 0xED, 0x82, 0x7C, 0x75, 0x6D, 0xE2, 0xA6, 0x9D, 0xD0, 0xFB, 0x1D, 0xFF, 0xFF, 0xFF, 0x1F, 0x30, 
0x41, 0x4E, 0xAB, 0x68, 0x71, 0x79, 0x81, 0xEE, 0x86, 0x87, 0xFE, 0xFE, 0xFE, 0xFE, 0xFE, 0x86, 0x85, 0xED, 0x82, 0x7A, 
0xB7, 0xE5, 0xB0, 0xA0, 0x43, 0x35, 0x23, 0xFD, 0xFF, 0xFF, 0x26, 0x38, 0xBF, 0xDD, 0x60, 0xE6, 0x75, 0x7F, 0xED, 0x86, 
0x87, 0xFE, 0xFE, 0xFE, 0xFE, 0xFE, 0xFE, 0xFE, 0x86, 0x85, 0xED, 0xBB, 0x77, 0x6E, 0xE2, 0xA5, 0xC4, 0x3B, 0x28, 0x1C, 
0xFF, 0xFF, 0xDA, 0xF6, 0xC4, 0x56, 0xE3, 0x6E, 0x79, 0x82, 0x9B, 0x86, 0xFE, 0xFE, 0xFE, 0xFE, 0xFE, 0xFE, 0xFE, 0xFE, 
0x87, 0x86, 0x9B, 0x83, 0x7A, 0x89, 0x69, 0xAB, 0x4D, 0x3D, 0xFB, 0x1C, 0xFF, 0xFD, 0xFB, 0xD1, 0x4B, 0xA8, 0x67, 0x89, 
0x7B, 0xBC, 0x85, 0x87, 0xFE, 0xFE, 0xFE, 0xFE, 0xFE, 0xFE, 0xFE, 0xFE, 0xFE, 0x86, 0x84, 0xBC, 0x7D, 0xB8, 0x98, 0xAF, 
0xC8, 0x41, 0x2F, 0x1D, 0xFF, 0x1C, 0x2D, 0x3E, 0xF1, 0x88, 0x69, 0x8A, 0x7E, 0xED, 0x86, 0x87, 0xFE, 0xFE, 0xFE, 0xFE, 
0xFE, 0xFE, 0xFE, 0xFE, 0xFE, 0xBD, 0x84, 0xBC, 0x7F, 0x75, 0xB4, 0xB1, 0xA0, 0xF7, 0x31, 0x1F, 0xFF, 0x1C, 0x2E, 0x3E, 
0x4D, 0xAA, 0x69, 0xB7, 0x7D, 0xED, 0x86, 0x87, 0xFE, 0xFE, 0xFE, 0xFE, 0xFE, 0xFE, 0xFE, 0xFE, 0xFE, 0x86, 0x84, 0xBC, 
0x7E, 0x75, 0x6C, 0x5F, 0xA0, 0x42, 0x32, 0x1F, 0xFF, 0x1C, 0x2D, 0x3D, 0x4C, 0xA9, 0x68, 0x72, 0x8C, 0xBC, 0x85, 0x87, 
0xFE, 0xFE, 0xFE, 0xFE, 0xFE, 0xFE, 0xFE, 0xFE, 0xFE, 0x86, 0x9B, 0x83, 0x7D, 0x99, 0x6B, 0x5E, 0x51, 0xD6, 0x31, 0x1F, 
0xFF, 0xFF, 0x2B, 0xCF, 0x48, 0x58, 0xE3, 0x70, 0x79, 0x83, 0xEF, 0x86, 0xFE, 0xFE, 0xFE, 0xFE, 0xFE, 0xFE, 0xFE, 0xFE, 
0x87, 0x85, 0xED, 0x81, 0x7A, 0x73, 0x97, 0xAD, 0x50, 0xD3, 0x2E, 0x1D, 0xFF, 0xFF, 0x28, 0xD9, 0xC0, 0x54, 0xE1, 0xE8, 
0x8B, 0xEB, 0xED, 0x85, 0x87, 0xFE, 0xFE, 0xFE, 0xFE, 0xFE, 0xFE, 0x87, 0x86, 0x9B, 0xBC, 0x7F, 0x78, 0x6F, 0xB3, 0xA9, 
0x4C, 0xD0, 0x2B, 0x1C, 0xFF, 0xFF, 0x24, 0x35, 0xF7, 0xC7, 0x5C, 0x69, 0x72, 0x8D, 0x83, 0xEE, 0x85, 0x87, 0xFE, 0xFE, 
0xFE, 0xFE, 0x87, 0x86, 0x9B, 0xBC, 0x81, 0x7A, 0x99, 0xB4, 0x61, 0x54, 0xC3, 0xD8, 0x27, 0xFF, 0xFF, 0xFF, 0x1D, 0x2E, 
0xD0, 0x48, 0x55, 0x62, 0xE7, 0x75, 0x7D, 0x83, 0xED, 0x84, 0x86, 0x86, 0x86, 0x86, 0x85, 0xEE, 0xBC, 0x81, 0x7D, 0x76, 
0x6F, 0x68, 0xAB, 0xC8, 0xD5, 0xFA, 0x22, 0xFF, 0xFF, 0xFF, 0xFF, 0xDB, 0x38, 0x43, 0x50, 0x5B, 0x66, 0x6E, 0x76, 0x8F, 
0x81, 0xBC, 0xED, 0xED, 0xEE, 0xED, 0xBC, 0x83, 0xEB, 0x7C, 0x77, 0x71, 0xE4, 0xB2, 0x91, 0xC4, 0xCD, 0x2A, 0x1C, 0xFF, 
0xFF, 0xFF, 0xFF, 0x1E, 0x2E, 0xCF, 0xC3, 0x52, 0x5D, 0x67, 0x6E, 0x75, 0x79, 0x7E, 0xEB, 0x81, 0x81, 0x80, 0x7F, 0x7D, 
0x79, 0x75, 0x70, 0x6A, 0x61, 0x58, 0xF1, 0xD4, 0x32, 0x23, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xDC, 0x34, 0x3E, 0x47, 
0x53, 0xDE, 0x65, 0x6C, 0x89, 0x75, 0x78, 0x79, 0x79, 0x79, 0x78, 0x75, 0x72, 0x6D, 0x69, 0x61, 0x58, 0x9F, 0xBE, 0xD7, 
0xFC, 0x1C, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFD, 0xFC, 0x37, 0xD3, 0x47, 0x90, 0x5A, 0x61, 0x68, 0xE6, 0xE9, 0x70, 
0x71, 0x71, 0x6F, 0xE7, 0x97, 0x96, 0xAF, 0x92, 0x4E, 0x44, 0x3C, 0xFB, 0x1D, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 
0xFF, 0x1C, 0x29, 0x37, 0x3E, 0xC1, 0x4F, 0xA3, 0xAA, 0x94, 0x63, 0x65, 0x66, 0xB3, 0xE3, 0x95, 0x93, 0xA7, 0xA0, 0xC5, 
0x42, 0xCB, 0x2C, 0x1F, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0x1C, 0xFC, 0x33, 0xCE, 0xD6, 0xC4, 
0x4F, 0xA2, 0xA4, 0x58, 0xA8, 0x58, 0xA5, 0x91, 0xCA, 0x9E, 0xF0, 0x3F, 0xF8, 0x2B, 0x20, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 
0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFD, 0x25, 0x2D, 0x38, 0xCF, 0x41, 0x45, 0x9C, 0x49, 0x4A, 0x9D, 0x47, 0xC2, 
0xBE, 0xD2, 0xD9, 0xF9, 0xDB, 0x1D, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 
0xFF, 0x1E, 0x27, 0x2D, 0x34, 0x39, 0xCC, 0xCF, 0xD1, 0xD0, 0xCE, 0xD9, 0x36, 0x2F, 0xFC, 0x22, 0xFF, 0xFF, 0xFF, 0xFF, 
0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0x1D, 0x23, 0x27, 0x29, 0xFB, 
0x2C, 0x2C, 0x2B, 0xFC, 0x25, 0x1D, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 
0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFD, 0x1C, 0xFD, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 
0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x54, 0x52, 0x55, 
0x45, 0x56, 0x49, 0x53, 0x49, 0x4F, 0x4E, 0x2D, 0x58, 0x46, 0x49, 0x4C, 0x45, 0x2E, 0x00
};

//---------------------------------------------------------------------------

u32 CShadowFake::s_ProfileShadowFake = 0;

//---------------------------------------------------------------------------

CShadowFake::CShadowFake(ISceneNode * parent) 
	: m_Parent(parent), m_TopParent(NULL),
	m_FakeShadowLightsUsed(0), m_AlphaInterpolation(1.0f),
	m_Driver(VIDEO_DRIVER), m_Profiler(PROFILER), m_SceneManager(SCENE_MANAGER),
	m_GroundPlaneValid(false),
	m_LightingHighQuality(DEVICE.getDeviceFlagValue(dev::EDCF_LIGHTING_HIGH_QUALITY))
{
#if MY_DEBUG_MODE 
    setClassName("CShadowFake");
#endif

	img::SColor shadow_color = m_Driver.getShadowColor();

	s32 sh_r = shadow_color.getRed();
	s32 sh_g = shadow_color.getGreen();
	s32 sh_b = shadow_color.getBlue();
	s32 sh_a = shadow_color.getAlpha();

	f32 f_r = sh_r / 255.0f * 1.25f;
	f32 f_g = sh_g / 255.0f * 1.25f;
	f32 f_b = sh_b / 255.0f * 1.25f;
	f32 f_a = sh_a / 255.0f * 1.25f;

	CHECK_RANGE(f_r, 0.0f, 1.0f);
	CHECK_RANGE(f_g, 0.0f, 1.0f);
	CHECK_RANGE(f_b, 0.0f, 1.0f);
	CHECK_RANGE(f_a, 0.0f, 1.0f);

	ISceneNode* imposter = m_Parent->getImposter();
	m_ParentImposter = SAFE_CAST_TO_BILLBOARD_SCENE_NODE(imposter);

	if (m_ParentImposter)
	{
		SAFE_GRAB(m_ParentImposter);
	}

	vid::ITexture *t = m_Driver.findTexture("#DefaultFakeShadow");

	if (!t)
	{
		io::IReadFile *file = FILE_SYSTEM.createMemoryReadFile(
				file_data, FILE_LENGTH, "#DefaultFakeShadow", false);
		img::IImage *img = IMAGE_LIBRARY.getImage(file);		
		if (img)
		{
			img->convertTo(img::ECF_A8R8G8B8);
			core::dimension2di dim = img->getDimension();
			for (s32 x=0; x<dim.Width; x++)
			{
				for (s32 y=0; y<dim.Height; y++)
				{
					s32 r = img->getPixel(x, y).getRed();
					s32 g = img->getPixel(x, y).getGreen();
					s32 b = img->getPixel(x, y).getBlue();
					img::SColor pixel(
						f_a * r, f_a * f_r * r, f_a * f_g * r, f_a * f_b * r);
					img->setPixel(x, y, pixel);
				}
			}
			t = VIDEO_DRIVER.addTexture("#DefaultFakeShadow", img);
		}
		file->drop();
	}

	vid::SRenderPass &p = m_Material.getPass(0);
	p.setFlag(vid::EMF_BLENDING, false);
	p.setFlag(vid::EMF_ZWRITE_ENABLE, false);
	p.setFlag(vid::EMF_BACK_FACE_CULLING, false);
	p.setDepthTest(vid::ECT_LESS);
	p.setAlphaTest(vid::EAT_GE_80);

	if (!s_ProfileShadowFake)
		s_ProfileShadowFake = m_Profiler.allocProfileId("Shadow Fake");
}

//---------------------------------------------------------------------------

CShadowFake::~CShadowFake()
{
	SAFE_DROP(m_ParentImposter);

	m_DLights.clear();
	m_DLightsHash.clear();
	
	for (u32 i=0; i<m_FakeShadowLights.size(); ++i)
		SAFE_DELETE(m_FakeShadowLights[i]);
	m_FakeShadowLights.clear();
	m_FakeShadowLightsUsed =0;
}

//---------------------------------------------------------------------------

void CShadowFake::registerForRendering(
	bool fake_shadow, u32 nowMs,
	const vid::SLight &light0, u64 enabled_lights,
	IAnimatedMesh *amesh, IMesh *mesh, bool render_debug)
{
	if (!m_Parent || !m_ParentImposter)
		return;

	m_Profiler.startProfiling(s_ProfileShadowFake);

	f32 now = (f32)nowMs;
	_applyLights(now, light0, enabled_lights);

	s32 animation_idx = m_ParentImposter->getCurrentAnimation();
	s32 dir_cnt = m_ParentImposter->
		getAnimationDirectionSetsCount(animation_idx);	

	if (dir_cnt > 0)
	{
		m_ParentImposter->storeTransformation();			
		u32 lcnt = m_DLights.size();
		for (u32 i = 0; i < lcnt; i++)
		{
			SDynamicLightEntry *dl = m_DLights[i];
			if (dl->Updated && (
					dl->ActionType != SDynamicLightEntry::laNone ||
					dl->CastShadowsNow))
				_registerGeometryFromLight(now, *dl, render_debug);
		}
		m_ParentImposter->restoreTransformation();
		m_FakeShadowLightsUsed = 0;
	}

	m_Profiler.stopProfiling(s_ProfileShadowFake);
}

//---------------------------------------------------------------------------

void CShadowFake::_registerGeometryFromLight(
	f32 now, SDynamicLightEntry &dlight, bool render_debug)
{
     // allocating memory for shadow volume	

	CLightShadowGround* svp = 0;
    if (m_FakeShadowLights.size() > (u32)m_FakeShadowLightsUsed)
    {
        // get the next unused buffer
        svp = m_FakeShadowLights[m_FakeShadowLightsUsed];
    }
    else
    {
        // add a new buffer
		svp = new CLightShadowGround();
        m_FakeShadowLights.push_back(svp);     		
    }  
	++m_FakeShadowLightsUsed;

	const core::vector3df             &node_pos         = m_ParentAbsolutePosition;
	const SImposterParameters         &imp_params       = *m_Parent->getImposterParameters();
	const SImposterCreationParameters &imp_creat_params = *m_Parent->getImposterCreationParameters();
	const core::matrix4               &abs_transf       = m_ParentAbsoluteTransformation;	
	const core::matrix4               &abs_transf_inv   = m_ParentAbsoluteTransformationInv;

	core::vector3df lposabs	= dlight.AbsPosition;
	core::vector3df ldirabs	= node_pos - lposabs;
	{
		f32 a      = ldirabs.getAngleDeg(core::vector3df(0,-1,0));
		f32 a_rad  = core::DEG2RAD*(a);
		f32 imp_opt_ang_rad_min = core::DEG2RAD*(40);
		f32 imp_opt_ang_rad_max = core::DEG2RAD*(80);
		if (a_rad > imp_opt_ang_rad_max ||
			a_rad < imp_opt_ang_rad_min)
		{
			f32 t = 0.0f;
			if (a_rad > imp_opt_ang_rad_max)
				t = core::math::Tan(imp_opt_ang_rad_max) /
					core::math::Tan(a_rad);
			else
				t = core::math::Tan(a_rad) /
					core::math::Tan(imp_opt_ang_rad_min);
			ldirabs.Y = ldirabs.Y * t;
			ldirabs.normalize();
			ldirabs *= 1000.0f;
			lposabs = node_pos - ldirabs;
		}
	}

	img::SColor shadow_color = m_Driver.getShadowColor();
	f32 alpha_coeff1 = 1.0f;
	f32 alpha_coeff2 = m_AlphaInterpolation;
	if (dlight.ActionType == SDynamicLightEntry::laDisappearing)
		alpha_coeff1 = 1.0f - fabs(now - dlight.ActionStartTime) /
			dlight.ActionLifeTime;					
	else if (dlight.ActionType == SDynamicLightEntry::laAppearing)
		alpha_coeff1 = fabs(now - dlight.ActionStartTime) /
			dlight.ActionLifeTime;
	CHECK_RANGE(alpha_coeff1, 0.0f, 1.0f);
	CHECK_RANGE(alpha_coeff2, 0.0f, 1.0f);

	s32 newalpha = (f32)shadow_color.getAlpha() *
		alpha_coeff1 * alpha_coeff2;
	shadow_color.setAlpha(newalpha);

	scn::ISceneNode *owner = NULL;
	if (!dlight.Light.Dynamic && (
			dlight.ActionType != SDynamicLightEntry::laNone ||
			m_AlphaInterpolation < 1.0f))
		owner = m_ParentImposter;

	core::vector3df vec = lposabs;
	core::matrix4 inv_abs = m_Parent->getAbsoluteTransformation();
	inv_abs.makeInversed();					
	inv_abs.transformVect(vec);	
	vec.normalize();
	vec *= imp_params.ViewOffset;

	core::vector3df shift = imp_params.ShiftCustom + vec;
	core::vector3df bbox_center = m_Parent->getBoundingBox().getCenter();

	if (imp_params.Centered)
		shift += bbox_center;				
	else
		shift += imp_params.ShiftBBCenter;			

	m_ParentImposter->setScale(m_Parent->getScale());
	m_ParentImposter->setPosition(shift);
	m_ParentImposter->updateAbsoluteTransformation();

	vid::ITexture* shadow_tex = 
		m_ParentImposter->getCurrentAnimationTextureForCameraPosition(lposabs);

	static u16 indices[] =
	{
		0, 1, 2,
		0, 2, 3,
		0, 3, 4,
		0, 4, 5,
		0, 5, 6,
		0, 6, 7
	};
    static vid::S3DVertex1TCoords vertices[4];

	m_ParentImposter->getCornersCoordinatesForView(
		lposabs, node_pos,
		vertices[3].Pos, vertices[2].Pos,
		vertices[1].Pos, vertices[0].Pos);

	vertices[3].TCoords = m_ParentImposter->getTCoords0();
	vertices[2].TCoords = m_ParentImposter->getTCoords1();
	vertices[1].TCoords = m_ParentImposter->getTCoords2();
	vertices[0].TCoords = m_ParentImposter->getTCoords3();		

	if (render_debug)
	{
		for (u32 i = 0; i < 4; i++)
			m_Driver.register3DLineForRendering(
				vid::ERP_3D_SOLID_PASS, core::matrix4(),
				vertices[i].Pos, vertices[(i + 1) % 4].Pos,
				0xff005500,
				true);
	}

	if (m_GroundPlaneValid)
	{
		for (u32 i = 0; i < 4; i++)
			m_GroundPlane.getIntersectionWithLine(
				vertices[i].Pos, ldirabs, vertices[i].Pos);
	}

	svp->BoundingBox.reset(vertices[0].Pos);
	svp->BoundingBox.addInternalPoint(vertices[1].Pos);
	svp->BoundingBox.addInternalPoint(vertices[2].Pos);
	svp->BoundingBox.addInternalPoint(vertices[3].Pos);
	svp->TransformedBoundingBox = svp->BoundingBox;

	svp->setLight(dlight);
	_updateShadowGround(dlight, svp);
	svp->onLightShadowCasted(
		dlight, scn::ESHT_SHADOW_FAKE, owner, shadow_color);

	m_Material.getPass(0).Layers[0].setTexture(shadow_tex);

	f32 zorder = dlight.Light.Dynamic ? -1.0f : svp->m_ZOrder;

	m_Driver.registerGeometryForRendering(
		vid::ERP_3D_LIGHTING_PASS,
		core::matrix4(), dlight.Index, m_Material,
		vertices, 4, vid::EVT_1TCOORDS,
		indices, 6, EIT_16_BIT,
		vid::EDPT_TRIANGLE_LIST, zorder,
		vid::ERM_RENDER_INTO_STENCIL, owner);

	if (render_debug)
	{
		for (u32 i = 0; i < 4; i++)
			m_Driver.register3DLineForRendering(
				vid::ERP_3D_SOLID_PASS, core::matrix4(),
				vertices[i].Pos, vertices[(i + 1) % 4].Pos,
				0xff005500,
				true);
		m_Driver.register3DBoxForRendering(
			vid::ERP_3D_SOLID_PASS, core::matrix4(),
			svp->TransformedBoundingBox,
			0xffffff00,
			true);
		m_Driver.register3DLineForRendering(
			vid::ERP_3D_SOLID_PASS, core::matrix4(),
			node_pos, lposabs,
			0xff00ff00,
			true);
	}
}

//---------------------------------------------------------------------------

void CShadowFake::_applyLights(
	f32 now, const vid::SLight &light0, u64 enabled_lights)
{
	m_TopParent = m_Parent;
	ISceneNode* root = m_SceneManager.getRootSceneNode();
	while (m_TopParent->getParent() != root)
		m_TopParent = m_TopParent->getParent();
	m_ParentBBox				= m_Parent->getBoundingBox();
	m_ParentTransformedBBox		= m_Parent->getTransformedBoundingBox();
	m_TopParentTransformedBBox	= m_TopParent->getTransformedBoundingBox();
	m_TopParentCenter			= m_TopParentTransformedBBox.getCenter();

	m_ParentAbsoluteTransformation		= m_Parent->getAbsoluteTransformation();
	m_ParentAbsolutePosition			= m_Parent->getAbsolutePosition();
	m_ParentAbsoluteTransformationInv	= m_ParentAbsoluteTransformation.getInversed();

	m_GroundPlaneValid = PATH_FINDER_MANAGER.isPointInsidePathFinding(m_TopParentCenter);

	if (m_GroundPlaneValid)
	{
		m_GroundPlane = core::plane3df(
			PATH_FINDER_MANAGER.getGroundPositionFor(m_TopParentCenter) +
			core::vector3df(0.0f, 5.0f, 0.0f), // Vertical Offset
			core::vector3df(0.0f, 1.0f, 0.0f)); // Up Vector
	}

	_clearDLights();

	const core::array <vid::SLight> &lights =
		m_Driver.getDynamicLights();
	u32 light_count = lights.size();

	for (u32 i = 0; i < light_count; i++)
	{
		if (enabled_lights & (u64)(1 << i))
			_addDLight(i == 0 ? light0 : lights[i], i, 100);
	}

	m_DLights.sort_ptr();
	_updateLights(now);
}

//---------------------------------------------------------------------------

void CShadowFake::_updateLights(f32 now)
{
	f32 PreRenderTime = now;

	f32 hlim = getShadowType() == ESHT_SHADOW_VOLUME ? 0.8f : 0.9f;
	f32 llim = hlim-0.01f;

	bool is_visible = false;

	u32 dlsize = m_DLights.size();
	for (u32 i = 0; i < dlsize; ++i)
	{
		SDynamicLightEntry *dl = m_DLights[i];

		// checking out used this light to build shadows or not

		dl->Distance = (dl->AbsPosition - m_TopParentCenter).getLength();

		bool cast_shadow_now = dl->CastShadowsNow;

		if (dl->Updated && dl->Light.CastShadows)
		{
			if (dl->Light.Type == vid::ELT_DIRECTIONAL)
			{
				if (!is_visible)
					cast_shadow_now = true;
				else
					cast_shadow_now = false;
			}
			else 			
			if (dl->Light.Radius>0 && dl->Distance < hlim * dl->Light.Radius)
			{
				if (dl->Distance < llim * dl->Light.Radius)
					cast_shadow_now = true;
			}
			else
				cast_shadow_now = false;
		}
		else
			cast_shadow_now = false;

		// this stuff is needed to smooth appearing/disappearing of the shadow

		bool action_started = false, action_just_started = false;		

		if (cast_shadow_now && !dl->CastShadowsNow)
		{
			if (dl->ActionType == SDynamicLightEntry::laNone)
				action_just_started = true;
			dl->ActionType = SDynamicLightEntry::laAppearing;
			action_started = true;
		}
		else if (!cast_shadow_now && dl->CastShadowsNow)
		{
			if (dl->ActionType == SDynamicLightEntry::laNone)
				action_just_started = true;
			dl->ActionType = SDynamicLightEntry::laDisappearing;
			action_started = true;
		}

		if (action_just_started)
		{
			dl->ActionStartTime = PreRenderTime;
			dl->ActionEndTime = dl->ActionStartTime + dl->ActionLifeTime;
		}
		else if (action_started && dl->ActionType != SDynamicLightEntry::laNone)
		{
			s32 dT = dl->ActionEndTime - PreRenderTime;
			dl->ActionStartTime = PreRenderTime - dT;
			dl->ActionEndTime = dl->ActionStartTime + dl->ActionLifeTime;
		}	

		if (PreRenderTime >= dl->ActionEndTime) 
		{	
			if (dl->ActionType == SDynamicLightEntry::laDisappearing)
				cast_shadow_now=false;
			dl->ActionType = SDynamicLightEntry::laNone;
		}

		if (cast_shadow_now || dl->CastShadowsNow ||
				dl->ActionType != SDynamicLightEntry::laNone)
			is_visible = true;	

		dl->CastShadowsNow = cast_shadow_now;
	}
}

//---------------------------------------------------------------------------

void CShadowFake::_updateShadowGround(
	const SDynamicLightEntry &dlight, CLightShadowGround *svp)
{
	if (dlight.Light.Dynamic)
		return;

	ICameraSceneNode *camera = m_SceneManager.getActiveCamera();
	if (!camera)
		return;

	core::rectf &sg_rect = svp->m_GroundRect;
	sg_rect.set(FLT_MAX, FLT_MAX, FLT_MIN, FLT_MIN);

	if (m_GroundPlaneValid)
	{
		// make billboard look to Camera

		const core::vector3df	&cam_pos		= camera->getAbsolutePosition();
		const core::vector3df	&node_pos		= m_ParentAbsolutePosition;
		const core::matrix4		&abs_transf		= m_ParentAbsoluteTransformation;	
		const core::matrix4		&abs_transf_inv	= m_ParentAbsoluteTransformationInv;
		const core::aabbox3df	&tbb			= m_ParentTransformedBBox;
		static vid::S3DVertexSimple	vertices[8];
		static core::array <vid::S3DVertexSimple> sg_vert(
			vertices, sizeof(vertices)/sizeof(*vertices));	

		for (u32 i = 0; i < 2; i++)
		{
			const core::vector3df &lposabs =
				(i == 0) ? dlight.AbsPosition : cam_pos;
			core::vector3df ldirabs = node_pos - lposabs;
			if (svp->getShadowType() == ESHT_SHADOW_FAKE)
			{
				sg_vert.set_used(2);
				sg_vert[0].Pos.set(
					svp->TransformedBoundingBox.MinEdge.X,
					svp->TransformedBoundingBox.MinEdge.Y,
					svp->TransformedBoundingBox.MinEdge.Z);
				sg_vert[1].Pos.set(
					svp->TransformedBoundingBox.MaxEdge.X,
					svp->TransformedBoundingBox.MinEdge.Y,
					svp->TransformedBoundingBox.MaxEdge.Z);
			}
			else
			{
				sg_vert.set_used(0);
				if (dlight.Light.Type == vid::ELT_DIRECTIONAL)
					tbb.getVisibilityContour(ldirabs, sg_vert, true);
				else
					tbb.getVisibilityContour(lposabs, sg_vert);
			}
			u32 vcnt = sg_vert.size();
			for (u32 j = 0; j < vcnt; j++)
			{
				core::vector3df &vpos	= sg_vert[j].Pos;
				core::vector2df &ul		= sg_rect.UpperLeftCorner;
				core::vector2df &lr		= sg_rect.LowerRightCorner;
				if (dlight.Light.Type == vid::ELT_DIRECTIONAL)
					m_GroundPlane.getIntersectionWithLine(
						vpos, ldirabs, vpos);
				else
					m_GroundPlane.getIntersectionWithLine(
						core::line3df(lposabs, vpos), vpos);
				if (ul.X > vpos.X) ul.X = vpos.X;
				if (ul.Y > vpos.Z) ul.Y = vpos.Z;
				if (lr.X < vpos.X) lr.X = vpos.X;
				if (lr.Y < vpos.Z) lr.Y = vpos.Z;
			}
		}
		svp->m_GroundY = m_GroundPlane.getMemberPoint().Y;
		svp->m_ZOrder = (s32)svp->m_GroundY / 10.0f;
	}
	else
	{
		svp->m_GroundY = 0.f;
		svp->m_ZOrder = 0.f;
	}
}

//---------------------------------------------------------------------------
} // end namespace scn
} // end namespace my
//---------------------------------------------------------------------------
